name: WebAssembly Build

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  release:
    types: [created]
  workflow_dispatch:

jobs:
  build-wasm:
    name: Emscripten Build
    runs-on: ubuntu-latest
    
    steps:
      # 检出代码，包括子模块
      - uses: actions/checkout@v4
        with:
          submodules: 'recursive'
      
      # 显示项目结构
      - name: Show project structure
        run: |
          echo "项目根目录内容:"
          ls -la
          echo "emscripten_port目录内容:"
          ls -la emscripten_port || echo "emscripten_port目录不存在"
          echo "wowViewerLib目录内容:"
          ls -la wowViewerLib || echo "wowViewerLib目录不存在"
          echo "查找CMakeLists.txt文件:"
          find . -name "CMakeLists.txt" | grep -v node_modules
      
      # 安装依赖
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ninja-build cmake libgl1-mesa-dev xorg-dev p7zip-full
          ninja --version
          cmake --version
          gcc --version
      
      # 安装Emscripten SDK
      - name: Install Emscripten SDK
        run: |
          echo "正在安装Emscripten SDK..."
          git clone https://github.com/emscripten-core/emsdk.git
          cd emsdk
          ./emsdk install 3.1.19
          ./emsdk activate 3.1.19
          echo "Emscripten SDK安装完成"
          
          EMSDK_PATH="$(pwd)"
          echo "EMSDK=$EMSDK_PATH" >> $GITHUB_ENV
          echo "PATH=$EMSDK_PATH:$EMSDK_PATH/upstream/emscripten:$PATH" >> $GITHUB_ENV
      
      # 验证Emscripten安装
      - name: Verify Emscripten
        run: |
          source $EMSDK/emsdk_env.sh
          emcc --version
      
      # 修复renderdoc相关问题（防止冲突）
      - name: Fix RenderDoc issues
        run: |
          echo "修复RenderDoc相关问题..."
          RENDERDOC_PATH="wowViewerLib/src/gapi/renderdoc_app.h"
          if [ -f "$RENDERDOC_PATH" ]; then
            # 备份原始文件
            cp "$RENDERDOC_PATH" "${RENDERDOC_PATH}.bak"
            
            # 在文件顶部添加Emscripten条件编译
            sed -i '1i\
            #ifdef __EMSCRIPTEN__\
            #define RENDERDOC_NO_STDINT\
            #define RENDERDOC_IMPORT_API 0\
            #define RENDERDOC_API_VERSION 10\
            #endif' "$RENDERDOC_PATH"
            
            echo "RenderDoc头文件已修改"
          fi
          
          # 创建补丁文件，处理Threads::Threads相关问题
          cat > tbb_threads_patch.patch << 'ENDOFPATCH'
          --- a/wowViewerLib/3rdparty/oneTbb/cmake/compilers/Clang.cmake
          +++ b/wowViewerLib/3rdparty/oneTbb/cmake/compilers/Clang.cmake
          @@ -19,7 +19,9 @@
           
           if (NOT MSVC)
               set(TBB_COMMON_COMPILE_FLAGS ${TBB_COMMON_COMPILE_FLAGS} -pthread)
          -    set_property(TARGET Threads::Threads PROPERTY INTERFACE_COMPILE_OPTIONS ${TBB_COMMON_COMPILE_FLAGS})
          +    if (TARGET Threads::Threads)
          +        set_property(TARGET Threads::Threads PROPERTY INTERFACE_COMPILE_OPTIONS ${TBB_COMMON_COMPILE_FLAGS})
          +    endif()
               set(TBB_COMMON_LINK_LIBS ${TBB_COMMON_LINK_LIBS} pthread dl)
           endif()
           
          ENDOFPATCH
          
          # 应用补丁
          patch -p1 < tbb_threads_patch.patch || echo "补丁应用失败，可能文件已修改或路径不匹配"
          
          # 创建CMake配置文件
          mkdir -p cmake_config
          cat > cmake_config/wasm_config.cmake << 'ENDOFCONFIG'
          # 禁用共享库
          set(BUILD_SHARED_LIBS OFF CACHE BOOL "Build shared libraries" FORCE)
          set(TBB_BUILD_SHARED OFF CACHE BOOL "Build TBB shared library" FORCE)
          set(TBB_ENABLE_SHARED OFF CACHE BOOL "Enable TBB shared library" FORCE)
          
          # TBB配置
          set(TBB_STRICT ON CACHE BOOL "Enable TBB strict mode" FORCE)
          set(TBB_TEST OFF CACHE BOOL "Enable TBB tests" FORCE)
          
          # Emscripten特定设置
          set(LINK_GLEW OFF CACHE BOOL "Link GLEW" FORCE)
          set(LINK_VULKAN OFF CACHE BOOL "Link Vulkan" FORCE)
          set(LINK_OPENMP OFF CACHE BOOL "Link OpenMP" FORCE)
          set(LINK_OGL4 OFF CACHE BOOL "Link OpenGL 4" FORCE)
          
          # 定义预处理宏
          add_definitions(-DEMSCRIPTEN)
          add_definitions(-DTBB_USE_EXCEPTIONS=0)
          ENDOFCONFIG
      
      # 构建项目 - 直接使用emscripten_port
      - name: Build WowViewerCpp for WebAssembly
        run: |
          source $EMSDK/emsdk_env.sh
          
          # 查看emscripten_port中的CMakeLists.txt
          echo "检查emscripten_port中的CMake文件:"
          cat emscripten_port/CMakeLists.txt || echo "emscripten_port/CMakeLists.txt不存在"
          
          # 创建构建目录
          mkdir -p build
          cd build
          
          # 配置项目
          echo "配置CMake..."
          emcmake cmake ../emscripten_port \
            -DCMAKE_BUILD_TYPE=Release \
            -C ../cmake_config/wasm_config.cmake \
            -DCMAKE_INSTALL_PREFIX=../wasm_output
          
          # 查看生成的CMake配置
          echo "检查生成的CMake配置..."
          cat CMakeCache.txt | grep -E "TBB|LINK_|BUILD_SHARED"
          
          # 构建项目
          echo "开始构建..."
          emmake make -j2 VERBOSE=1
          
          # 安装到输出目录
          echo "安装到输出目录..."
          emmake make install
          
          cd ..
      
      # 检查构建结果
      - name: Check build results
        run: |
          echo "检查构建产物..."
          
          # 检查编译输出目录
          echo "构建目录内容:"
          find build -type f -name "*.js" -o -name "*.wasm" -o -name "*.data" | sort
          
          # 检查wasm_output目录
          echo "安装目录内容:"
          find wasm_output -type f | sort
          
          # 检查build_packed目录
          echo "查找build_packed目录:"
          find . -name "build_packed" -type d
          
          if [ -d "build_packed" ]; then
            echo "build_packed目录内容:"
            find build_packed -type f | sort
            
            # 检查文件大小
            echo "检查WebAssembly文件大小:"
            find build_packed -type f -name "project.wasm" -exec du -h {} \;
          fi
      
      # 准备最终输出
      - name: Prepare final output
        run: |
          mkdir -p wasm_build
          
          # 尝试从多个可能的位置收集构建产物
          # 1. 从build_packed目录
          if [ -d "build_packed" ] && [ -f "build_packed/project.js" ]; then
            echo "从build_packed复制文件..."
            cp build_packed/project.js wasm_build/
            cp build_packed/project.wasm wasm_build/
            [ -f "build_packed/project.data" ] && cp build_packed/project.data wasm_build/
          # 2. 从安装目录
          elif [ -d "wasm_output" ]; then
            echo "从wasm_output复制文件..."
            find wasm_output -type f -name "*.js" -o -name "*.wasm" -o -name "*.data" -exec cp {} wasm_build/ \;
          # 3. 从构建目录
          else
            echo "搜索构建目录中的WebAssembly文件..."
            find build -type f -name "*.js" -o -name "*.wasm" -o -name "*.data" -exec cp {} wasm_build/ \;
          fi
          
          # 创建HTML模板文件
          echo "创建HTML模板..."
          cat > wasm_build/index.html << 'ENDOFHTML'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>WoW Viewer WebAssembly</title>
            <style>
              body { margin: 0; overflow: hidden; background-color: #111; }
              .container { display: flex; flex-direction: column; height: 100vh; }
              canvas { width: 100%; height: 100%; display: block; }
              #status { position: absolute; bottom: 10px; left: 10px; color: white; background-color: rgba(0,0,0,0.5); padding: 5px; }
            </style>
          </head>
          <body>
            <div class="container">
              <canvas id="canvas"></canvas>
              <div id="status">Loading...</div>
            </div>
            <script>
              var Module = {
                canvas: document.getElementById('canvas'),
                onRuntimeInitialized: function() {
                  document.getElementById('status').textContent = 'WebAssembly initialized';
                },
                print: function(text) {
                  console.log(text);
                  document.getElementById('status').textContent = text;
                },
                printErr: function(text) {
                  console.error(text);
                }
              };
            </script>
            <script async src="project.js"></script>
          </body>
          </html>
          ENDOFHTML
          
          echo "最终输出目录内容:"
          ls -la wasm_build/
          
          # 检查WebAssembly文件大小
          echo "检查最终WebAssembly文件大小:"
          if [ -f "wasm_build/project.wasm" ]; then
            du -h wasm_build/project.wasm
          else
            echo "未找到project.wasm文件!"
          fi
      
      # 上传构建产物
      - name: Upload WebAssembly artifacts
        uses: actions/upload-artifact@v4
        with:
          name: wasm-build
          path: wasm_build/
          if-no-files-found: warn
      
      # 如果是发布，打包并上传
      - name: Pack release asset
        if: github.event_name == 'release' && (github.event.action == 'published' || github.event.action == 'created')
        run: |
          if [ -d "wasm_build" ] && [ "$(ls -A wasm_build 2>/dev/null)" ]; then
            cd wasm_build
            7z a ../wasm-build.zip .
            echo "已创建wasm-build.zip"
            cd ..
            du -h wasm-build.zip
          else
            echo "警告: wasm_build目录为空，无法创建发布包"
            exit 1
          fi
      
      # 上传发布资源
      - name: Upload release asset
        if: github.event_name == 'release' && (github.event.action == 'published' || github.event.action == 'created')
        uses: softprops/action-gh-release@v2
        with:
          files: wasm-build.zip