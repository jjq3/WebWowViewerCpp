name: WebAssembly Build

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  release:
    types: [created]
  workflow_dispatch:

jobs:
  build-wasm:
    name: Emscripten Build
    runs-on: ubuntu-latest
    
    steps:
      # 检出代码，包括子模块
      - uses: actions/checkout@v4
        with:
          submodules: 'recursive'
      
      # 显示项目结构
      - name: Show project structure
        run: |
          echo "项目根目录内容:"
          ls -la
          echo "emscripten_port目录内容:"
          ls -la emscripten_port || echo "emscripten_port目录不存在"
          echo "wowViewerLib目录内容:"
          ls -la wowViewerLib || echo "wowViewerLib目录不存在"
      
      # 安装依赖
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y ninja-build cmake libgl1-mesa-dev xorg-dev p7zip-full
          ninja --version
          cmake --version
          gcc --version
      
      # 安装Emscripten SDK
      - name: Install Emscripten SDK
        run: |
          echo "正在安装Emscripten SDK..."
          git clone https://github.com/emscripten-core/emsdk.git
          cd emsdk
          ./emsdk install 3.1.19
          ./emsdk activate 3.1.19
          echo "Emscripten SDK安装完成"
          
          EMSDK_PATH="$(pwd)"
          echo "EMSDK=$EMSDK_PATH" >> $GITHUB_ENV
          echo "PATH=$EMSDK_PATH:$EMSDK_PATH/upstream/emscripten:$PATH" >> $GITHUB_ENV
      
      # 验证Emscripten安装
      - name: Verify Emscripten
        run: |
          source $EMSDK/emsdk_env.sh
          emcc --version
      
      # 创建输出目录
      - name: Create output directory
        run: |
          mkdir -p wasm_build
          echo "创建输出目录: wasm_build"
      
      # 修改WowViewerLib的CMakeLists.txt
      - name: Modify WowViewerLib CMakeLists.txt
        run: |
          if [ -f "wowViewerLib/CMakeLists.txt" ]; then
            echo "修改wowViewerLib/CMakeLists.txt"
            
            # 备份原始文件
            cp wowViewerLib/CMakeLists.txt wowViewerLib/CMakeLists.txt.bak
            
            # 修改EMSCRIPTEN部分，禁用SPIRV和shader编译
            sed -i '/if (EMSCRIPTEN)/,/ENDIF()/c\if (EMSCRIPTEN)\n    message(This is EMSCRIPTEN)\n    set(LINK_GLEW 0)\n    set(LINK_VULKAN OFF)\n    set(LINK_OPENMP 0)\n    set(LINK_OGL4 0)\n    set(DISABLE_SPIRV_REFLECTION ON)\n    set(DISABLE_SHADER_COMPILATION ON)\n    set(USE_SHADERS_CACHE OFF)\n    set(TBB_STRICT ON CACHE BOOL "")\n    if (NOT EMSCRIPTEN_SIMD)\n        set(ENABLE_SIMD 0)\n    endif()\n    add_definitions("-DTBB_USE_EXCEPTIONS=0")\n    add_definitions("-DDISABLE_SPIRV")\n    add_definitions("-DDISABLE_VULKAN")\nENDIF()' wowViewerLib/CMakeLists.txt
            
            # 检查修改结果
            echo "修改后的EMSCRIPTEN部分:"
            grep -A 15 "if (EMSCRIPTEN)" wowViewerLib/CMakeLists.txt
          else
            echo "wowViewerLib/CMakeLists.txt不存在"
          fi
      
      # 修改emscripten_port的CMakeLists.txt
      - name: Modify emscripten_port CMakeLists.txt
        run: |
          if [ -f "emscripten_port/CMakeLists.txt" ]; then
            echo "修改emscripten_port/CMakeLists.txt"
            
            # 备份原始文件
            cp emscripten_port/CMakeLists.txt emscripten_port/CMakeLists.txt.bak
            
            # 在文件顶部添加禁用选项
            sed -i '1a\
            # 禁用SPIRV和shader编译\
            set(DISABLE_SPIRV_REFLECTION ON CACHE BOOL "Disable SPIRV reflection" FORCE)\
            set(DISABLE_SHADER_COMPILATION ON CACHE BOOL "Disable shader compilation" FORCE)\
            set(USE_SHADERS_CACHE OFF CACHE BOOL "Disable shader cache" FORCE)\
            ' emscripten_port/CMakeLists.txt
            
            # 检查修改结果
            echo "修改后的文件顶部:"
            head -n 10 emscripten_port/CMakeLists.txt
          else
            echo "emscripten_port/CMakeLists.txt不存在"
          fi
      
      # 创建存根文件
      - name: Create stub files
        run: |
          # 创建存根目录
          mkdir -p stubs
          echo "创建着色器存根文件..."
          
          # 创建存根顶点着色器
          echo "#version 300 es\nvoid main() {}" > stubs/stub.vert
          
          # 创建存根片段着色器
          echo "#version 300 es\nvoid main() {}" > stubs/stub.frag
          
          # 创建存根SPIRV二进制文件
          head -c 1024 /dev/zero > stubs/stub.spv
          
          # 创建一个自定义SPIRV反射工具存根
          mkdir -p scripts
          cat > scripts/spirv_stub.js << 'ENDOFSCRIPT'
          #!/usr/bin/env node
          console.log("SPIRV反射存根执行成功");
          console.log("输出目录: " + process.argv[4]);
          console.log("输入文件: " + process.argv[5]);
          // 创建一个空的输出文件
          const fs = require('fs');
          const path = require('path');
          const outputDir = process.argv[4];
          if (!fs.existsSync(outputDir)) {
            fs.mkdirSync(outputDir, { recursive: true });
          }
          fs.writeFileSync(path.join(outputDir, 'spirv_reflection.h'), '// 自动生成的存根文件\n#pragma once\n');
          process.exit(0);
          ENDOFSCRIPT
          chmod +x scripts/spirv_stub.js
      
      # 构建项目
      - name: Build WowViewerCpp
        run: |
          source $EMSDK/emsdk_env.sh
          
          # 创建构建目录
          mkdir -p build
          cd build
          
          # 创建CMake配置文件
          cat > wasm_config.cmake << 'ENDOFCONFIG'
          # 禁用共享库
          set(BUILD_SHARED_LIBS OFF CACHE BOOL "Build shared libraries" FORCE)
          set(TBB_BUILD_SHARED OFF CACHE BOOL "Build TBB shared library" FORCE)
          set(TBB_ENABLE_SHARED OFF CACHE BOOL "Enable TBB shared library" FORCE)
          
          # 禁用高级功能
          set(LINK_GLEW OFF CACHE BOOL "Link GLEW" FORCE)
          set(LINK_VULKAN OFF CACHE BOOL "Link Vulkan" FORCE)
          set(LINK_OPENMP OFF CACHE BOOL "Link OpenMP" FORCE)
          set(LINK_OGL4 OFF CACHE BOOL "Link OpenGL 4" FORCE)
          
          # 禁用着色器处理
          set(DISABLE_SPIRV_REFLECTION ON CACHE BOOL "Disable SPIRV reflection" FORCE)
          set(DISABLE_SHADER_COMPILATION ON CACHE BOOL "Disable shader compilation" FORCE)
          set(USE_SHADERS_CACHE OFF CACHE BOOL "Disable shader cache" FORCE)
          
          # 定义预处理宏
          add_definitions(-DEMSCRIPTEN)
          add_definitions(-DTBB_USE_EXCEPTIONS=0)
          add_definitions(-DDISABLE_SPIRV)
          add_definitions(-DDISABLE_VULKAN)
          ENDOFCONFIG
          
          # 配置项目
          echo "配置CMake..."
          emcmake cmake ../emscripten_port \
            -DCMAKE_BUILD_TYPE=Release \
            -C wasm_config.cmake \
            -DDISABLE_SPIRV_REFLECTION=ON \
            -DDISABLE_SHADER_COMPILATION=ON \
            -DUSE_SHADERS_CACHE=OFF
          
          # 检查生成的配置
          echo "检查CMake缓存..."
          grep -E "SPIRV|SHADER|VULKAN" CMakeCache.txt || echo "未找到相关配置"
          
          # 构建项目
          echo "开始构建..."
          emmake make -j2 VERBOSE=1
          
          # 返回到根目录
          cd ..
      
      # 使用ESBuild构建最小版本（如果主构建失败）
      - name: Build minimal version
        if: failure()
        run: |
          echo "主构建失败，构建最小版本..."
          
          # 确保输出目录存在
          mkdir -p wasm_build
          
          # 创建一个简单的C文件
          mkdir -p minimal_build
          cd minimal_build
          
          echo '#include <emscripten.h>
          #include <stdio.h>
          EMSCRIPTEN_KEEPALIVE
          int main() {
            printf("WoW Viewer WebAssembly Minimal Version\\n");
            return 0;
          }' > minimal.c
          
          # 编译最小版本
          source $EMSDK/emsdk_env.sh
          emcc minimal.c -o project.js -s WASM=1
          
          # 复制文件到输出目录
          cp project.js ../wasm_build/
          cp project.wasm ../wasm_build/
          
          cd ..
      
      # 收集构建产物
      - name: Collect build artifacts
        run: |
          # 确保输出目录存在
          mkdir -p wasm_build
          
          echo "收集构建产物..."
          # 从build目录搜索
          if [ -d "build" ]; then
            echo "搜索build目录中的产物..."
            find build -name "*.js" -o -name "*.wasm" -o -name "*.data" | xargs -I{} cp -v {} wasm_build/ || echo "未找到构建产物"
          fi
          
          # 从build_packed目录搜索
          if [ -d "build_packed" ]; then
            echo "搜索build_packed目录中的产物..."
            find build_packed -name "*.js" -o -name "*.wasm" -o -name "*.data" | xargs -I{} cp -v {} wasm_build/ || echo "未找到构建产物"
          fi
          
          # 如果没有找到，尝试全局搜索
          if [ ! "$(ls -A wasm_build 2>/dev/null)" ]; then
            echo "在指定目录未找到产物，尝试全局搜索..."
            find . -name "project.js" -o -name "project.wasm" -o -name "project.data" | grep -v "node_modules" | xargs -I{} cp -v {} wasm_build/ || echo "未找到构建产物"
          fi
          
          echo "wasm_build目录内容:"
          ls -la wasm_build/
      
      # 创建HTML文件
      - name: Create HTML file
        run: |
          # 确保输出目录存在
          mkdir -p wasm_build
          
          cat > wasm_build/index.html << 'ENDOFHTML'
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>WoW Viewer WebAssembly</title>
            <style>
              body { margin: 0; overflow: hidden; background-color: #111; }
              .container { display: flex; flex-direction: column; height: 100vh; }
              canvas { width: 100%; height: 100%; display: block; }
              #status { position: absolute; bottom: 10px; left: 10px; color: white; background-color: rgba(0,0,0,0.5); padding: 5px; }
            </style>
          </head>
          <body>
            <div class="container">
              <canvas id="canvas"></canvas>
              <div id="status">Loading...</div>
            </div>
            <script>
              var Module = {
                canvas: document.getElementById('canvas'),
                onRuntimeInitialized: function() {
                  document.getElementById('status').textContent = 'WebAssembly initialized';
                },
                print: function(text) {
                  console.log(text);
                  document.getElementById('status').textContent = text;
                },
                printErr: function(text) {
                  console.error(text);
                }
              };
            </script>
            <script async src="project.js"></script>
          </body>
          </html>
          ENDOFHTML
      
      # 上传构建产物
      - name: Upload WebAssembly artifacts
        uses: actions/upload-artifact@v4
        with:
          name: wasm-build
          path: wasm_build/
          if-no-files-found: warn
      
      # 如果是发布，打包并上传
      - name: Pack release asset
        if: github.event_name == 'release' && (github.event.action == 'published' || github.event.action == 'created')
        run: |
          # 确保输出目录存在并且不为空
          if [ -d "wasm_build" ] && [ "$(ls -A wasm_build 2>/dev/null)" ]; then
            cd wasm_build
            7z a ../wasm-build.zip .
            echo "已创建wasm-build.zip"
            cd ..
            du -h wasm-build.zip
          else
            echo "警告: wasm_build目录为空，无法创建发布包"
            exit 1
          fi
      
      # 上传发布资源
      - name: Upload release asset
        if: github.event_name == 'release' && (github.event.action == 'published' || github.event.action == 'created')
        uses: softprops/action-gh-release@v2
        with:
          files: wasm-build.zip